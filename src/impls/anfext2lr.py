import numpy as np
import random

from ._interface import Producer, Recoverer, GeneratorProducer

# NOTE: fails to transmit some degenerate payloads e.g. D = 0


# Works by generating transitions of the form:
#     x = A@F(x)
# with A constructed as:
#     A = [D  Z] S
# where D is the payload matrix (n×m), Z is a deterministic redundant
# matrix (n×(2^n-1-m)) and S is an M×M (M=2^n-1) full-rank matrix
# built from a Gray-code permutation of monomials.
#
# The recoverer knows Z and S, and uses:
#   Y = A F = [D Z] S F = [D Z] U,  U = S F
#   split U = (U_u, U_l) with U_u ∈ GF(2)^m, U_l ∈ GF(2)^{M-m}
#   Y = D U_u + Z U_l  ⇒  D = (Y + Z U_l) U_u^{-1}
#

# For now S = const gray code permutation
#         Z = determenistically rand N x (2^N - 1 - M)
# TODO: find better ways to construct (S, Z) given N and M

# ================================================================
# ======================  Helper functions  ======================
# ================================================================


def vector_to_int(bits):
    """Convert binary vector to integer (MSB first)."""
    v = 0
    for b in bits:
        v = (v << 1) | int(b)
    return v


def add_to_basis_rref_vector(v_bits, basis):
    """
    Insert v_bits into a GF(2) basis kept in row-reduced echelon style.

    v_bits: np array of shape (k,)
    basis: list of int masks (each a k-bit vector, encoded as int)
    """
    # convert to int mask
    v = vector_to_int(v_bits)

    # eliminate using existing basis rows
    for r in basis:
        pivot = 1 << (r.bit_length() - 1)
        if v & pivot:
            v ^= r

    if v == 0:
        return False, basis

    # Now v is new pivot
    pivot = 1 << (v.bit_length() - 1)
    new_basis = []
    for r in basis:
        if r & pivot:
            r ^= v
        new_basis.append(r)

    new_basis.append(v)
    new_basis.sort(reverse=True)
    return True, new_basis


# ================================================================
# ===============  ANF monomials and feature map  ================
# ================================================================


def generate_monomial_masks(N, M):
    """
    Return the first M *non-constant* ANF monomials (degree >= 1)
    in degree-then-lex order.
    """
    masks = [s for s in range(1, 1 << N)]  # skip s=0
    masks.sort(key=lambda s: (bin(s).count("1"), s))
    return masks[:M]


def anf_feature_vector(x_bits, monomial_masks):
    """
    Compute F(x): the ANF monomial feature vector.
    x_bits: shape (N,), dtype uint8
    monomial_masks: list[int] of length M
    """
    # convert x to mask
    xmask = 0
    for b in x_bits:
        xmask = (xmask << 1) | int(b)

    out = []
    for m in monomial_masks:
        out.append(1 if (xmask & m) == m else 0)
    return np.array(out, dtype=np.uint8)


# ================================================================
# ============  Deterministic Z and Gray-code matrix S ===========
# ================================================================


def _make_Z(n: int, m: int) -> np.ndarray:
    """
    Deterministically construct redundant matrix Z of shape (n, M-m),
    where M = 2^n - 1.

    Bits are generated by a local RNG seeded by (n, m).
    """
    M = (1 << n) - 1
    r = M - m
    if r < 0:
        raise ValueError("m cannot exceed 2^n - 1 for ANF monomials")
    if r == 0:
        return np.zeros((n, 0), dtype=np.uint8)

    seed = (n * 1000003) ^ (m * 10007) ^ 0x9E3779B9
    rng = random.Random(seed)
    data = [rng.getrandbits(1) for _ in range(n * r)]
    Z = np.array(data, dtype=np.uint8).reshape(n, r)
    return Z


def _build_gray_permutation_matrix(n: int, monomial_masks):
    """
    Build an M×M permutation matrix S (M = 2^n - 1) that reorders
    monomials according to an n-bit Gray code sequence over non-zero masks.

    Row t of S has a single 1 in column j, where monomial_masks[j] is
    the (t+1)-th Gray-code mask (skipping 0).
    """
    M = len(monomial_masks)
    assert M == (1 << n) - 1, "monomial_masks must contain all non-zero masks"

    mask_to_index = {mask: j for j, mask in enumerate(monomial_masks)}
    S = np.zeros((M, M), dtype=np.uint8)

    # n-bit Gray code: g(i) = i ^ (i >> 1), i from 0..2^n-1
    # We skip i=0 (mask 0) and use i=1..2^n-1 as our order.
    for t in range(M):
        i = t + 1
        g = i ^ (i >> 1)  # Gray-coded mask in [1, 2^n-1]
        j = mask_to_index[g]
        S[t, j] = 1

    return S


# ================================================================
# ==================  Nonlinear Producer  ========================
# ================================================================


def nonlinear_producer(
    n: int,
    m: int,
    index: int,
    d: int,
    allow_consecutive_repetitions: bool = False,
    verbose: bool = False,
):
    """
    Raw-matrix nonlinear producer implementing the traversal logic with
    A = [D Z] S, where:
      - D is n×m payload (encoded in index, d = 2^(n*m)),
      - Z is deterministic n×(2^n-1-m),
      - S is an M×M Gray-permutation matrix (M=2^n-1).

    States evolve as:  x_{t+1} = A F(x_t),
    where F(x) is the ANF monomial feature map over ALL non-constant
    monomials (dimension M = 2^n - 1).
    """

    # ------------------------------------------------------------
    # 1. Decode the raw payload index → D (n×m)
    # ------------------------------------------------------------
    assert d == 2 ** (n * m), "invalid d for raw payload matrix D"

    bits = [(index >> k) & 1 for k in reversed(range(n * m))]
    D = np.array(bits, dtype=np.uint8).reshape((n, m))

    if verbose:
        print("Payload D=\n", D)

    # ------------------------------------------------------------
    # 2. Build full monomials, Z and S, then A = [D Z] S
    # ------------------------------------------------------------
    M = (1 << n) - 1  # full feature dimension
    if m > M:
        raise ValueError("m > 2^n - 1 is impossible for ANF monomials")

    monomial_masks = generate_monomial_masks(n, M)  # all non-constant monomials
    Z = _make_Z(n, m)  # shape (n, M-m)
    S = _build_gray_permutation_matrix(n, monomial_masks)  # (M×M)

    # Concatenate [D Z] to n×M and then multiply by S (M×M)
    A = np.concatenate([D, Z], axis=1)  # n×M
    A = (A @ S) % 2  # n×M

    if verbose:
        print("Producer A=[D Z]S=\n", A)

    # ------------------------------------------------------------
    # helpers
    # ------------------------------------------------------------
    def int_to_vec(x):
        return np.array([(x >> (n - 1 - i)) & 1 for i in range(n)], dtype=np.uint8)

    def vec_to_int(v):
        out = 0
        for b in v:
            out = (out << 1) | int(b)
        return out

    def nonlinear_step(x):
        xb = int_to_vec(x)
        F = anf_feature_vector(xb, monomial_masks)  # length M
        yb = (A @ F) % 2
        return vec_to_int(yb)

    # ------------------------------------------------------------
    # 3. Compute TAILS: states with no incoming transitions
    # ------------------------------------------------------------
    Nstates = 1 << n
    incoming_count = [0] * Nstates

    for x in range(Nstates):
        y = nonlinear_step(x)
        incoming_count[y] += 1

    tails = [x for x in range(Nstates) if incoming_count[x] == 0]

    if verbose:
        print(f"[Producer] Tails: {tails}")

    # ------------------------------------------------------------
    # 4. Traversal state (pseudocode)
    # ------------------------------------------------------------
    visited = {0}
    all_states = set(range(Nstates))
    prev = 0
    curr = 1

    if verbose:
        print("[Producer] Start traversal at curr=1")

    # ------------------------------------------------------------
    # 5. Main loop
    # ------------------------------------------------------------
    while True:

        # Case 1: revisiting a state
        if curr in visited:

            # Optionally output the repeated state
            if curr != 0 and (allow_consecutive_repetitions or prev != 0):
                if verbose:
                    print(f"[Producer] revisit → yield {curr:0{n}b}")
                yield int_to_vec(curr)

            # Always output separator
            if verbose:
                print("[Producer] yield separator 0…0")
            yield np.zeros(n, dtype=np.uint8)

            # Reset visited if full coverage
            if len(visited) == Nstates:
                if verbose:
                    print("[Producer] visited full → reset to {0}")
                visited = {0}

            # Clear prev
            prev = 0

            # Choose next starting state
            tails_unvisited = set(tails) - visited
            remaining = all_states - visited

            if tails_unvisited:
                curr = random.choice(list(tails_unvisited))
                if verbose:
                    print(f"[Producer] jump to TAIL {curr:0{n}b}")
            else:
                curr = random.choice(list(remaining))
                if verbose:
                    print(f"[Producer] jump to ANY unvisited {curr:0{n}b}")

            # Continue — do NOT emit curr here

        # Case 2: normal new state
        if verbose:
            print(f"[Producer] yield {curr:0{n}b}")

        yield int_to_vec(curr)

        # Mark visited
        visited.add(curr)
        prev = curr

        # Nonlinear update
        curr = nonlinear_step(curr)


# ================================================================
# ===================  Nonlinear Recoverer  ======================
# ================================================================


class NonlinearRecoverer(Recoverer):
    """Recover payload matrix D from transitions (x → y = [D Z] S F(x))."""

    def __init__(self, n, m, verbose=False):
        self.n = n
        self.m = m
        self.M = (1 << n) - 1  # full feature dimension
        self.verbose = verbose

        # streaming state
        self.prev = None
        self.transitions = set()
        self.recovered_index = None

        # full monomial set, Z and S must match producer
        self.masks = generate_monomial_masks(n, self.M)
        self.Z = _make_Z(n, m)  # n×(M-m)
        self.S = _build_gray_permutation_matrix(n, self.masks)

    # --------------------------------------
    def feed(self, data):
        if data is None:
            if self.verbose:
                print("[Recoverer] GAP → reset prev")
            self.prev = None
            return self.recovered_index

        data = np.array(data, dtype=np.uint8) % 2

        # Zero separator
        if np.all(data == 0):
            if self.verbose:
                print("[Recoverer] SEPARATOR (zero vector) → reset prev")
            self.prev = None
            return self.recovered_index

        # If we have a previous nonzero, record transition
        if self.prev is not None and not np.all(self.prev == 0):
            pair = (tuple(self.prev.tolist()), tuple(data.tolist()))
            if pair not in self.transitions:
                if self.verbose:
                    print(
                        f"[Recoverer] ADD transition: {self.prev.tolist()} → {data.tolist()}"
                    )
                self.transitions.add(pair)
            else:
                if self.verbose:
                    print("[Recoverer] Transition duplicate, ignoring")
        self.prev = data.copy()

        # If already recovered
        if self.recovered_index is not None:
            return self.recovered_index

        # Need at least m transitions to hope for m×m U_u
        if len(self.transitions) < self.m:
            if self.verbose:
                print(
                    f"[Recoverer] Not enough transitions yet ({len(self.transitions)}/{self.m})"
                )
            return None

        # ======================================================
        # Collect m independent U_u vectors (first m coords of U=S F)
        # ======================================================
        basis = []
        UX_u = []
        Y_eff = []
        count = 0

        r = self.M - self.m  # width of Z / lower part of U

        if self.verbose:
            print(
                f"\n[Recoverer] BEGIN collecting independent U_u; "
                f"transitions={len(self.transitions)}"
            )

        for x_bits, y_bits in self.transitions:
            x = np.array(x_bits, dtype=np.uint8)
            Fx = anf_feature_vector(x, self.masks)  # length M
            U = (self.S @ Fx) % 2  # length M
            U_u = U[: self.m]  # length m
            U_l = U[self.m :]  # length r
            y = np.array(y_bits, dtype=np.uint8)

            # effective RHS: Y_eff = Y + Z U_l
            if r > 0:
                Zu = (self.Z @ U_l) % 2
                y_eff = (y + Zu) % 2
            else:
                y_eff = y

            if self.verbose:
                print(f"  U_u={U_u.tolist()}  from x={x.tolist()}")

            indep, new_basis = add_to_basis_rref_vector(U_u, basis)

            if indep:
                if self.verbose:
                    pivot_bit = new_basis[-1].bit_length() - 1
                    print(f"    → INDEPENDENT (pivot bit={pivot_bit})")
                    print(f"      basis size grows {len(basis)} → {len(new_basis)}")

                basis = new_basis
                UX_u.append(U_u)
                Y_eff.append(y_eff)
                count += 1
            else:
                if self.verbose:
                    print("    → DEPENDENT (ignored)")

            if count == self.m:
                break

        if count < self.m:
            if self.verbose:
                print(
                    f"[Recoverer] Only found {count}/{self.m} independent U_u — cannot solve yet."
                )
            return None

        # ======================================================
        # Build X_u (m×m) and Y_eff_mat (n×m) and solve for D
        # ======================================================
        X_u = np.column_stack(UX_u)  # m×m
        Y_eff_mat = np.column_stack(Y_eff)  # n×m

        if self.verbose:
            print(f"\n[Recoverer] BUILT MATRICES for D:")
            print(f"  X_u shape = {X_u.shape}")
            print(f"  Y_eff shape = {Y_eff_mat.shape}")
            print(f"  X_u=\n{X_u}")
            print(f"  Y_eff=\n{Y_eff_mat}")

        try:
            D = self._solve_mod2(Y_eff_mat, X_u)
        except np.linalg.LinAlgError:
            if self.verbose:
                print("[Recoverer] X_u was singular → retry later")
            return None

        if self.verbose:
            print("[Recoverer] SUCCESS — solved D (payload):")
            print(D)

        self.recovered_index = self._matrix_to_index(D)
        return self.recovered_index

    # --------------------------------------
    def _matrix_to_index(self, A):
        idx = 0
        for r in range(A.shape[0]):
            for c in range(A.shape[1]):
                idx = (idx << 1) | int(A[r, c])
        return idx

    # --------------------------------------
    @staticmethod
    def _solve_mod2(Y, X):
        """
        Solve A from Y = A X over GF(2), where X is square (m×m)
        and Y is n×m.
        """
        M = X.shape[0]  # square
        aug = np.concatenate([X.copy(), np.eye(M, dtype=np.uint8)], axis=1)
        # Gauss–Jordan eliminate X → I_M
        for i in range(M):
            pivot = None
            for r in range(i, M):
                if aug[r, i]:
                    pivot = r
                    break
            if pivot is None:
                raise np.linalg.LinAlgError("singular")
            if pivot != i:
                aug[[i, pivot]] = aug[[pivot, i]]
            for r in range(M):
                if r != i and aug[r, i]:
                    aug[r] ^= aug[i]
        Xinv = aug[:, M:]
        return (Y @ Xinv) % 2  # n×M


# ================================================================
# ========  D, producer_constructor, recoverer_constructor  ======
# ================================================================

# theoretically can handle up to D = 2^(n*2^n), where M=2^n
# but in practice large M starts to fail
override_D = lambda n: 2 ** (n * (2 ** (n - 1)))


def _infer_m_from_d(n, d):
    """Given n and d = 2^(n*m), solve for m."""
    from math import log2

    power = log2(d)
    m = int(power / n)
    if 2 ** (n * m) != d:
        raise ValueError(f"d={d} is not 2^(n*m) for integer m")
    # must also satisfy m <= 2^n - 1 (max non-constant monomials)
    if m > (1 << n) - 1:
        raise ValueError("m > 2^n - 1 is impossible for ANF monomials")
    return m


def producer_constructor(index: int, n: int, d: int) -> Producer:
    """
    Automatically choose m such that d = 2^(n*m) and m ≤ 2^n - 1.
    Payload is the n×m matrix D; generator constructs A = [D Z] S.
    """
    m = _infer_m_from_d(n, d)
    return GeneratorProducer(nonlinear_producer(n, m, index, d))


def recoverer_constructor(n: int, d: int) -> Recoverer:
    """
    Automatically choose m such that d = 2^(n*m), and recover only D
    from transitions, using known Z and S.
    """
    m = _infer_m_from_d(n, d)
    return NonlinearRecoverer(n, m)


skip = True
